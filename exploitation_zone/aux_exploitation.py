def create_schema(db_url, schema_path):
    """
    Create schema in the scpecified db.
    """
    import sqlalchemy
    from sqlalchemy import create_engine

    schema = open(schema_path)
    engine = create_engine(db_url)

    escaped_sql = sqlalchemy.text(schema.read())
    engine.execute(escaped_sql)

    return

def entity_resolution(l1, l2):
    import numpy as np
    import pandas as pd
    import enchant

    set1 = l1.copy()
    set2 = l2.copy()
    d = {}

    # for loop for those equals
    to_remove = []
    for i in range(len(set1)):
        if len(set1) == 0 or len(set2) == 0:
            break
       
        elem1 = set1[i]
        for j in range(len(set2)):
            
            elem2 = set2[j]
            lev = enchant.utils.levenshtein(elem1, elem2)

            if lev == 0:
                d[elem1] = elem2
                to_remove.append(elem1)
                set2.remove(elem2)
                break

    for elem in to_remove:
        set1.remove(elem)

    # for loop for those similar
    for i in range(len(set1)):
        if len(set1) == 0 or len(set2) == 0:
            break

        elem1 = set1[i]
        min_lev = 99
        min_elem = elem1
        for j in range(len(set2)):
            elem2 = set2[j]
            lev = enchant.utils.levenshtein(elem1, elem2)

            if lev < min_lev and lev < 3:
                min_lev = lev
                min_elem = elem2

        if lev != 0:
            d[elem1] = min_elem
            set2.remove(min_elem)

    return(d)

def integrate_countries(db_url_source,):
    import sqlalchemy
    from sqlalchemy import create_engine
    import pandas as pd

    engine_source = create_engine(db_url_source)
    source_conn = engine_source.connect()

    dwgi = pd.read_sql_table('wgi', source_conn)
    dwbd = pd.read_sql_table('wbd', source_conn)
    dc = pd.read_sql_table('countries_dim', source_conn)

    kwgi = dwgi['code'].unique().tolist()
    kwbd = dwbd['economy'].unique().tolist()
    kc = dc['iso'].unique().tolist()

    dct_wgi = entity_resolution(kwgi, kc)
    inv_wgi = {v: k for k, v in dct_wgi.items()}

    dct_wbd = entity_resolution(kwbd, kc)
    inv_wbd = {v: k for k, v in dct_wbd.items()}

    dc['wgi_map'] = dc['iso'].map(inv_wgi)
    dc['wbd_map'] = dc['iso'].map(inv_wbd)

    source_conn.close()
    return dc

def integrate_years(colname='id'):
    import datetime
    import numpy as np
    import pandas as pd
    
    starting_year = 1900
    current_year = int(datetime.datetime.now().date().strftime('%Y'))
    year_list = np.arange(starting_year, current_year+1)
    df = pd.DataFrame(year_list, columns=[colname])
    return df

def populate_dimensions(db_url_source, db_url_schema):
    import numpy as np
    import pandas as pd
    import sqlalchemy
    from sqlalchemy import create_engine
    from sqlalchemy import inspect
    from sqlalchemy import MetaData
    from sqlalchemy.dialects.postgresql import insert as pg_insert

    engine_schema = create_engine(db_url_schema)
    schema_conn = engine_schema.connect()
    inspector = inspect(engine_schema)
    schema_table_names = inspector.get_table_names()

    engine_source = create_engine(db_url_source)
    source_conn = engine_source.connect()

    countries_source = integrate_countries(db_url_source)
    countries_schema = pd.read_sql_table('countries_dim', schema_conn)
    cols = np.intersect1d(countries_schema.columns, countries_source.columns)
    countries = countries_source[cols].to_dict('records')

    years = integrate_years().to_dict('records')

    meta = MetaData()
    meta.reflect(bind=engine_schema)
    stmt = pg_insert(meta.tables['countries_dim']).values(countries).on_conflict_do_nothing()
    schema_conn.execute(stmt)
    stmt = pg_insert(meta.tables['years_dim']).values(years).on_conflict_do_nothing()
    schema_conn.execute(stmt)
    
    source_conn.close()
    schema_conn.close()
    return
            

def populate_facts(db_url_source, db_url_schema):
    """
    Populate schema with the proper data.
    """
    import numpy as np
    import pandas as pd
    import sqlalchemy
    from sqlalchemy import create_engine
    from sqlalchemy import inspect
    from sqlalchemy import MetaData
    from sqlalchemy.dialects.postgresql import insert as pg_insert

    engine_schema = create_engine(db_url_schema)
    schema_conn = engine_schema.connect()
    inspector = inspect(engine_schema)
    schema_table_names = inspector.get_table_names()

    engine_source = create_engine(db_url_source)
    source_conn = engine_source.connect()

    facts = []
    for table in schema_table_names:
        if 'dim' not in table:
            facts.append(table)

    for table in facts:
        df_schema = pd.read_sql_table(table, schema_conn)
        df_source = pd.read_sql_table(table, source_conn)

        cols = np.intersect1d(df_schema.columns, df_source.columns)
        data = df_source[cols].to_dict('records')

        meta = MetaData()
        meta.reflect(bind=engine_schema)
        stmt = pg_insert(meta.tables[table]).values(data).on_conflict_do_nothing()
        schema_conn.execute(stmt)

    source_conn.close()
    schema_conn.close()
    return

def profile_schema(db_url_schema, replace=False, output_path='./profiling'):
    
    import os
    import pandas as pd
    from sqlalchemy import create_engine, inspect
    from pandas_profiling import ProfileReport

    engine = create_engine(db_url_schema)
    conn = engine.connect()

    inspector = inspect(engine)
    schema = inspector.get_table_names()

    for table in schema:
        if ("profiling_{}.html".format(table)) in os.listdir(output_path) and not replace: # Exists and replace=False
            continue
        elif 'dim' in table:
            df = pd.read_sql_table(table, conn)
            profile = ProfileReport(df, title="{}".format(table), minimal=True)
            profile.to_file(os.path.join(output_path, "profiling_{}.html".format(table)))
        else:
            df = pd.read_sql_table(table, conn)
            profile = ProfileReport(df, title="{}".format(table))
            profile.to_file(os.path.join(output_path, "profiling_{}.html".format(table)))

    conn.close()
    return
